

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/r2net_favicon.png">
  <link rel="icon" href="/img/r2net_favicon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="百二一">
  <meta name="keywords" content="">
  
    <meta name="description" content="MinGW 的全称是：Minimalist GNU on Windows 。它实际上是将经典的开源 C语言 编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。">
<meta property="og:type" content="article">
<meta property="og:title" content="简单易懂的MinGW-w64安装教程：著名C语言编译器GCC的Windows版本">
<meta property="og:url" content="https://rsreland.net/blog/202002172024/index.html">
<meta property="og:site_name" content="百二一">
<meta property="og:description" content="MinGW 的全称是：Minimalist GNU on Windows 。它实际上是将经典的开源 C语言 编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.50121.top/img/2020/02/200217_1.png">
<meta property="article:published_time" content="2020-02-17T12:24:33.000Z">
<meta property="article:modified_time" content="2025-10-14T11:17:26.137Z">
<meta property="article:author" content="百二一">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="编译器">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.50121.top/img/2020/02/200217_1.png">
  
  
  
  <title>简单易懂的MinGW-w64安装教程：著名C语言编译器GCC的Windows版本 | 百二一</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"rsreland.net","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"EKdmASjIRBzDpmdhjJvD7sQ7-MdYXbMMI","app_key":"3xhpLOaU8oKm2IGn0JVL08dW","server_url":"https://leancloud.rsreland.net","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>百二一</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/series/" target="_self">
                <i class="iconfont icon-codeforces"></i>
                <span>系列</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/thanks/" target="_self">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>感谢</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/message/" target="_self">
                <i class="iconfont icon-speakernotes"></i>
                <span>留言</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/r2net_banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="简单易懂的MinGW-w64安装教程：著名C语言编译器GCC的Windows版本"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-02-17 20:24" pubdate>
          2020年2月17日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          57 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">简单易懂的MinGW-w64安装教程：著名C语言编译器GCC的Windows版本</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年10月14日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><img src="https://img.50121.top/img/2020/02/200217_1.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《简单易懂的MinGW-w64安装教程》这篇文章由 <strong>百二一</strong> （<a href="https://rsreland.net/">https://rsreland.net</a> ）于 <strong>2016年09月24日</strong> 编写，MinGW-w64 对应的 gcc 是 <strong>6.2.0</strong> 版本（也可能适用6.3.0及以上版本），运行环境是 <strong>Windows10</strong> 操作系统。（<strong>请注意本文的编写时间，及软件版本，来判断本文是否还有效。</strong>）</p>
<p>本文主要讲述如何安装 C语言 编译器——MinGW-w64，特点是文章附有完整详细的实际安装过程截图，文字反而起说明提示作用。</p>
<p>编写本文的原因始于我的一个观点：图片可以比文字传达更多的信息，也能让其他人更容易理解作者的意图及思想。因此，我将安装 MinGW-w64 的过程和步骤，编写成了这篇以图片为主的教程，为了让看到这篇文章的任何人，都可以很容易按照图片所示正确安装 MinGW-w64。</p>
<p>我希望写出一篇新手也可以看懂的 MinGW-w64 安装教程。</p>
<p>　</p>
<p>　</p>
<h1 id="什么是-MinGW-w64-？"><a href="#什么是-MinGW-w64-？" class="headerlink" title="什么是 MinGW-w64 ？"></a>什么是 MinGW-w64 ？</h1><p>MinGW 的全称是：Minimalist GNU on Windows 。它实际上是将经典的开源 C语言 编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux平台下的开发工具。一句话来概括：MinGW 就是 GCC 的 Windows 版本 。</p>
<p>以上是 MinGW 的介绍，MinGW-w64 与 MinGW 的区别在于 MinGW 只能编译生成32位可执行程序，而 MinGW-w64 则可以编译生成 64位 或 32位 可执行程序。</p>
<p>正因为如此，MinGW 现已被 MinGW-w64 所取代，且 MinGW 也早已停止了更新，内置的 GCC 停滞在了 4.8.1 版本，而 MinGW-w64 内置的 GCC 则更新到了 6.2.0 版本。</p>
<p>　</p>
<p>　</p>
<h1 id="为什么使用-MinGW-w64-？"><a href="#为什么使用-MinGW-w64-？" class="headerlink" title="为什么使用 MinGW-w64 ？"></a>为什么使用 MinGW-w64 ？</h1><ol>
<li>MinGW-w64 是开源软件，可以免费使用。</li>
<li>MinGW-w64 由一个活跃的开源社区在持续维护，因此不会过时。</li>
<li>MinGW-w64 支持最新的 C语言 标准。</li>
<li>MinGW-w64 使用 Windows 的C语言运行库，因此编译出的程序不需要第三方 DLL ，可以直接在 Windows 下运行。</li>
<li>那些著名的开源 IDE 实际只是将 MinGW-w64 封装了起来，使它拥有友好的图形化界面，简化了操作，但内部核心仍然是 MinGW-w64。</li>
</ol>
<p>MinGW-w64 是稳定可靠的、持续更新的 C&#x2F;C++ 编译器，使用它可以免去很多麻烦，不用担心跟不上时代，也不用担心编译器本身有bug，可以放心的去编写程序。</p>
<p>　</p>
<p>　</p>
<h1 id="MinGW-w64-适合做什么？"><a href="#MinGW-w64-适合做什么？" class="headerlink" title="MinGW-w64 适合做什么？"></a>MinGW-w64 适合做什么？</h1><p>对于熟悉 MinGW-w64 的高手而言，它可以编译任何 C语言 程序。但对于一般人来说，MinGW-w64 太过简陋，连图形用户界面都没有。这让习惯使用鼠标的人，感到很痛苦。虽然也可以通过一些配置，让 MinGW-w64 拥有图形用户界面，但那个过程非常麻烦。</p>
<p>除此之外，编译复杂的程序时，还需要你会编写 Makefile ，否则只能一个文件一个文件的编译，可想而知会多么辛苦。</p>
<p>但对于初学 C语言 的人来说，MinGW-w64 是正合适的编译器，至少黑色的命令提示符界面很有编程的气氛，感觉很酷。</p>
<p>在刚开始学 C语言 时，所有代码通常都写在一个文件中，只要输入几个简单的命令，就能用 MinGW-w64 编译成可执行文件。虽然  VS2015 等编译器，只要点击下鼠标就可以完成编译，但它会自动生成一大堆工程文件，让初学者摸不着头脑。而 MinGW-w64 则只会生成一个可执行文件。</p>
<p>如果对 MinGW-w64 和 VS2015 等编译器进行一下形容，那么 MinGW-w64 是手动的，而  VS2015 等编译器则是自动的。因此 MinGW-w64 的编译过程更加直观容易理解，也比较适合C语言学习。</p>
<p>总而言之，对于一般人来说，MinGW-w64 适合学习 C语言 时使用，真正工作还是用  VS2015 更好。当然如果您是在 Linux 下工作，那么Code::Blocks可能是一个选择，不过最大的可能是您必须习惯使用 GCC 来编译程序。</p>
<p>　</p>
<p>　</p>
<h1 id="下载和安装-MinGW-w64"><a href="#下载和安装-MinGW-w64" class="headerlink" title="下载和安装 MinGW-w64"></a>下载和安装 MinGW-w64</h1><p>在开始安装之前，请先确认您满足以下几个条件。</p>
<ol>
<li>您的电脑已经连接到网络。</li>
<li>您的电脑硬盘有500MB的剩余空间。</li>
<li>您现在有充足的时间。（受您当前网速的影响，安装过程可能会花费10几分钟或1个小时以上的时间。）<br>如果您确认，您满足了上述条件，那么就可以开始安装 MinGW-w64 了。</li>
</ol>
<p><strong>注意：</strong>教程中的图片都是实际安装时的<strong>原比例截图</strong>，如果您看不清图片中的提示语，<strong>可以将图片放大</strong>，不会影响清晰度。想要观看大图，只需点击图片，就会跳转到原始尺寸的图片页面中。如果前面的方法失效，您仍然可以通过浏览器放大页面的功能，放大图片，例如在 Chrome 浏览器下，您可以按住 Ctrl 键，然后滚动鼠标滚轮，即可放大页面。</p>
<p>　</p>
<h2 id="MinGW-w64官方网站首页（https-mingw-w64-org-）"><a href="#MinGW-w64官方网站首页（https-mingw-w64-org-）" class="headerlink" title="MinGW-w64官方网站首页（https://mingw-w64.org/ ）"></a>MinGW-w64官方网站首页（<a target="_blank" rel="noopener" href="https://mingw-w64.org/">https://mingw-w64.org/</a> ）</h2><p><img src="https://img.50121.top/img/2020/02/200217_2.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>MinGW-w64 官方网站的地址是：<a target="_blank" rel="noopener" href="https://mingw-w64.org/">https://mingw-w64.org</a> ，首页样式如上图所示。</p>
<p><strong>操作：</strong>点击红框中的「<strong>Downloads</strong>」超链接，进入 MinGW-w64 下载详情页面。</p>
<p>　</p>
<h2 id="MinGW-w64下载详情页面"><a href="#MinGW-w64下载详情页面" class="headerlink" title="MinGW-w64下载详情页面"></a>MinGW-w64下载详情页面</h2><p><img src="https://img.50121.top/img/2020/02/200217_3.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>这是 MinGW-w64 的下载详情页面。首先看到一个标题为 Pre-built toolchains and packages 的列表，这里面是包含 MinGW-w64 及特定工具的整合包。我们这个教程只安装 MinGW-w64 ，所以只需下载 MinGW-w64 即可。</p>
<p><strong>操作：</strong>点击红框中的「<strong>SourceForge</strong>」超链接，就会进入 SourceForge 中的 MinGW-w64 下载页面。</p>
<p>　</p>
<h2 id="SourceForge-中的-MinGW-w64-下载页面"><a href="#SourceForge-中的-MinGW-w64-下载页面" class="headerlink" title="SourceForge 中的 MinGW-w64 下载页面"></a>SourceForge 中的 MinGW-w64 下载页面</h2><p><img src="https://img.50121.top/img/2020/02/200217_4.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>MinGW-w64 的代码和可执行文件被托管存储在 SourceForge 上，在这个页面上就可以直接下载 MinGW-w64 了。MinGW-w64 是非常复杂的，编译器大多都是如此，为了适应各种操作系统，它们的组件会存在各种不同的版本，以适应不同的环境。所以，我们直接下载 MinGW-w64 的安装程序，它会按照我们的需要，再自动下载适合的组件，并将它们组织在一起。</p>
<p><strong>操作：</strong>点击红框中的「<strong>Download mingw-w64-install.exe</strong>」超链接，将会下载这个 MinGW-w64 自动安装的程序。</p>
<p>　</p>
<h2 id="等待-MinGW-w64-安装程序开始下载"><a href="#等待-MinGW-w64-安装程序开始下载" class="headerlink" title="等待 MinGW-w64 安装程序开始下载"></a>等待 MinGW-w64 安装程序开始下载</h2><p><img src="https://img.50121.top/img/2020/02/200217_5.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>5秒钟之后，浏览器会自动下载 mingw-w64-install.exe 。</p>
<p><strong>操作：</strong>只需等待。</p>
<p><strong>注意：</strong>如果浏览器没有自动下载，则可以点击黄框中的「<strong>direct link</strong>」超链接，手动下载。如果下载速度非常慢，可以点击绿框中的「<strong>mirror</strong>」超链接，选择一个离自己近的镜像网站，可能会获得较高（无法保证）的下载速度。</p>
<p>　</p>
<h2 id="正在下载-mingw-w64-intall-exe"><a href="#正在下载-mingw-w64-intall-exe" class="headerlink" title="正在下载 mingw-w64-intall.exe"></a>正在下载 mingw-w64-intall.exe</h2><p><img src="https://img.50121.top/img/2020/02/200217_6.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>如果你的浏览器是 chrome ，那么在浏览器下部，会出现这样一个下载标签。</p>
<p><strong>操作：</strong>只需等待。</p>
<p>　</p>
<h2 id="MinGW-w64-安装程序"><a href="#MinGW-w64-安装程序" class="headerlink" title="MinGW-w64 安装程序"></a>MinGW-w64 安装程序</h2><p><img src="https://img.50121.top/img/2020/02/200217_7.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>这就是 MinGW-w64 的安装程序。它本质上是一个下载程序，会根据我们之后的一些设置，选择性的下载相应的组件，并将它们组织在一起。所以，运行前要确定网络通畅，而且你有足够的时间，因为根据你的网速，它可能需要花费一定的时间来下载。</p>
<p><strong>操作：</strong>用鼠标双击运行 <strong>mingw-w64-install.exe</strong> 。</p>
<p><strong>注意：</strong>如果出现无法运行，或者安装出错，你可以右键点击它，并在弹出窗口中选择「<strong>以管理员身份运行</strong>」选项，然后重新运行 mingw-w64-install.exe ，基本可以解决大部分问题。</p>
<p>　</p>
<h2 id="MinGW-w64-安装程序欢迎界面"><a href="#MinGW-w64-安装程序欢迎界面" class="headerlink" title="MinGW-w64 安装程序欢迎界面"></a>MinGW-w64 安装程序欢迎界面</h2><p><img src="https://img.50121.top/img/2020/02/200217_8.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>欢迎使用 MinGW-w64 在线安装程序。</p>
<p><strong>操作：</strong>点击红框中的 「<strong>Next</strong>」 按钮，将会进入下一步安装步骤。</p>
<p>　</p>
<h2 id="从服务器获取-MinGW-w64-文件信息"><a href="#从服务器获取-MinGW-w64-文件信息" class="headerlink" title="从服务器获取 MinGW-w64 文件信息"></a>从服务器获取 MinGW-w64 文件信息</h2><p><img src="https://img.50121.top/img/2020/02/200217_9.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>这里程序正在链接服务器，以便获取存储在仓库中的 MinGW-w64 的文件明细。</p>
<p><strong>操作：</strong>只需等待。</p>
<p>　</p>
<h2 id="MinGW-w64-版本选择"><a href="#MinGW-w64-版本选择" class="headerlink" title="MinGW-w64 版本选择"></a>MinGW-w64 版本选择</h2><p><img src="https://img.50121.top/img/2020/02/200217_10.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>在这个界面，你可以根据所要搭建的开发环境，选择不同的选项，从而下载所需的组件。</p>
<p><strong>操作：</strong>选择 <strong>Version、Architecture、Threads、Exception、Build revision</strong> 下拉列表中适当的选项，接下来将会详细介绍这些选项。</p>
<p>　</p>
<h3 id="选择-gcc-版本"><a href="#选择-gcc-版本" class="headerlink" title="选择 gcc 版本"></a>选择 gcc 版本</h3><p><img src="https://img.50121.top/img/2020/02/200217_11.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>Version 指的是 gcc 的版本，如果没有特殊的需求，一般选择最高的版本号即可。</p>
<p><strong>操作：</strong>在这个版本中，最高版本是 <strong>6.2.0</strong> ，选中它即可。</p>
<p>　</p>
<h3 id="选择电脑系统架构"><a href="#选择电脑系统架构" class="headerlink" title="选择电脑系统架构"></a>选择电脑系统架构</h3><p><img src="https://img.50121.top/img/2020/02/200217_12.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>Architecture 是指电脑系统是 32位 还是 64位，根据你的电脑系统做出对应选择。</p>
<p><strong>操作：</strong>我的电脑系统是 64位 的，所以我选择了 <strong>x86_64</strong>，如果你是 32位 系统，则选择 <strong>i686</strong> 即可。</p>
<p>　</p>
<h3 id="选择操作系统接口协议"><a href="#选择操作系统接口协议" class="headerlink" title="选择操作系统接口协议"></a>选择操作系统接口协议</h3><p><img src="https://img.50121.top/img/2020/02/200217_13.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>这个世界上只有两种操作系统，符合 posix 协议的，和 Windows 。如这个笑话所说的，如果你想要开发 Windows 程序，需要选择 win32 ，而开发 Linux、Unix、Mac OS 等其他操作系统下的程序，则需要选择 posix 。</p>
<p><strong>操作：</strong>我只开发在 Windows 下运行的程序，所以选择了 <strong>win32</strong> 。</p>
<p>　</p>
<h3 id="选择异常处理模型（64位）"><a href="#选择异常处理模型（64位）" class="headerlink" title="选择异常处理模型（64位）"></a>选择异常处理模型（64位）</h3><p><img src="https://img.50121.top/img/2020/02/200217_14.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>异常处理在开发中非常重要，你在开发的过程中，大部分的时间会耗在处理各种异常情况上。如果你之前选择了 64位，则这里有两个异常处理模型供你选择，seh 是新发明的，而 sjlj 则是古老的。seh 性能比较好，但不支持 32位。 sjlj 稳定性好，支持 32位。</p>
<p><strong>操作：</strong>我这里选择了 <strong>seh</strong> 。</p>
<p>　</p>
<h3 id="选择异常处理模型（32位）"><a href="#选择异常处理模型（32位）" class="headerlink" title="选择异常处理模型（32位）"></a>选择异常处理模型（32位）</h3><p><img src="https://img.50121.top/img/2020/02/200217_15.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>选择了 32位 后，则可以用 dwarf 和 sjlj 两种异常处理模型。同样的，dwarf 的性能要优于 sjlj ，但它不支持 64位 。</p>
<p><strong>操作：</strong>建议选择 dwarf 。</p>
<p>　</p>
<h3 id="建立修订"><a href="#建立修订" class="headerlink" title="建立修订"></a>建立修订</h3><p><img src="https://img.50121.top/img/2020/02/200217_16.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>暂时没弄明白是做什么的。（知道的人请留言）</p>
<p><strong>操作：</strong>选择 <strong>默认</strong> 选项。</p>
<p>　</p>
<h2 id="MinGW-w64-版本选择完成"><a href="#MinGW-w64-版本选择完成" class="headerlink" title="MinGW-w64 版本选择完成"></a>MinGW-w64 版本选择完成</h2><p><img src="https://img.50121.top/img/2020/02/200217_17.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>绿框中就是我的 MinGW-w64 安装配置单，gcc 是 6.2.0 版本，系统架构是 64位，接口协议是 win32，异常处理模型是 seh，Build revision 是 1 。</p>
<p><strong>操作：</strong>点击红框中的「<strong>Next</strong>」按钮，进入下一个步骤。</p>
<p>　</p>
<h2 id="选择-MinGW-w64-的安装目录"><a href="#选择-MinGW-w64-的安装目录" class="headerlink" title="选择 MinGW-w64 的安装目录"></a>选择 MinGW-w64 的安装目录</h2><p><img src="https://img.50121.top/img/2020/02/200217_18.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>在这里选择 MinGW-w64 将要安装到哪个目录中去。安装程序默认会将 MinGW-w64 安装在 C盘 ，而在 Windows 操作系统中 C盘 是系统盘，操作系统会被安装在这个盘里，而按照一般的习惯，我们尽量不把应用软件安装载系统盘里。因为以前的电脑使用的是机械硬盘，而机械硬盘频繁读写会降低效率，所以尽量将操作系统与应用软件放在不同的硬盘分区下。当然，现在的电脑大部分都配备了固态硬盘（SSD），而且通常作为系统盘来使用，因此已经没有读写效率的问题了。所以如果你还在用机械硬盘，就将 MinGW-w64 放到其他非系统盘里，如果使用固态硬盘，则可以放在安装程序提示的默认位置，或其他地方均可。</p>
<p><strong>操作：</strong>点击红框中的「<strong>Browse</strong>」按钮，以便更改 MinGW-w64 的安装位置。</p>
<p>　</p>
<h2 id="更改-MinGW-w64-的安装位置"><a href="#更改-MinGW-w64-的安装位置" class="headerlink" title="更改 MinGW-w64 的安装位置"></a>更改 MinGW-w64 的安装位置</h2><p><img src="https://img.50121.top/img/2020/02/200217_19.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>点开绿框中的「<strong>此电脑</strong>」，就可以打开一个树状列表，然后找到你想要将 MinGW-w64 安装到的位置。你也可以点击黄框中的「<strong>新建文件夹</strong>」按钮，创建一个新的目录。</p>
<p><strong>操作：</strong>选择好安装的目录后，点击红框中的「<strong>确定</strong>」按钮，之后安装程序将把 MinGW-w64 安装到那里。</p>
<p>　</p>
<h2 id="确认-MinGW-w64-安装目录"><a href="#确认-MinGW-w64-安装目录" class="headerlink" title="确认 MinGW-w64 安装目录"></a>确认 MinGW-w64 安装目录</h2><p><img src="https://img.50121.top/img/2020/02/200217_20.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>界面中的 Space available 指的是你选择的目录，所在的硬盘分区的剩余空间，而 MinGW-w64 至少会占用 <strong>500 MB</strong> 的空间。<strong>Create shortcuts in Start Menu</strong> 是说在开始菜单创建 MinGW-w64 的快捷方式，一般默认勾选即可。</p>
<p><strong>操作：</strong>确认安装目录没问题后，点击红框中的「<strong>Next</strong>」按钮，开始正式安装 MinGW-w64 。</p>
<p>　</p>
<h2 id="开始下载-MinGW-w64-本体"><a href="#开始下载-MinGW-w64-本体" class="headerlink" title="开始下载 MinGW-w64 本体"></a>开始下载 MinGW-w64 本体</h2><p><img src="https://img.50121.top/img/2020/02/200217_21.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>安装程序开始连接服务器，并从中下载 MinGW-w64 的本体文件，根据你的网络环境，下载所需的时间会有所不同。如果你临时有其他事情要做，可以点击「<strong>Cancel</strong>」按钮，取消本次安装。</p>
<p><strong>操作：</strong>只需等待。</p>
<p>　</p>
<h2 id="MinGW-w64-下载完成"><a href="#MinGW-w64-下载完成" class="headerlink" title="MinGW-w64 下载完成"></a>MinGW-w64 下载完成</h2><p><img src="https://img.50121.top/img/2020/02/200217_22.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>MinGW-w64 已经下载完成，我们可以在之前选择的安装目录下，找到它的各种组件文件。</p>
<p><strong>操作：</strong>点击红框中的「<strong>Next</strong>」按钮，继续下一个步骤。</p>
<p>　</p>
<h2 id="关闭-MinGW-w64-安装程序"><a href="#关闭-MinGW-w64-安装程序" class="headerlink" title="关闭 MinGW-w64 安装程序"></a>关闭 MinGW-w64 安装程序</h2><p><img src="https://img.50121.top/img/2020/02/200217_23.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>MinGW-w64 的安装程序已经完成了它的使命，但 MinGW-w64 还没有安装完成，之后我们还需要进行一些配置，才能正常使用它编译源代码。</p>
<p><strong>操作：</strong>点击红框中的「<strong>Finish</strong>」按钮，将关闭 MinGW-w64 安装程序。</p>
<p>　</p>
<h2 id="MinGW-w64-安装目录"><a href="#MinGW-w64-安装目录" class="headerlink" title="MinGW-w64 安装目录"></a>MinGW-w64 安装目录</h2><p><img src="https://img.50121.top/img/2020/02/200217_24.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>MinGW-w64 下载完成后的安装目录，包含1个文件夹：<strong>mingw64</strong>，3个文件：<strong>mingw-w64.bat、uninstall.exe、uninstall.ini</strong>，和1个快捷方式：<strong>mingw-w64</strong>。虽然 MinGW-w64 已经下载完成，但并没有安装完成，我们还需要配置一下操作系统的环境变量，将 MinGW-w64 的 <strong>bin</strong> 目录加入其中，使操作系统可以找到那些编译工具。</p>
<p><strong>操作：</strong>双击红框中的「<strong>mingw64</strong>」文件夹，进入其中。</p>
<p>　</p>
<h2 id="MinGW-w64-的-mingw64-文件夹"><a href="#MinGW-w64-的-mingw64-文件夹" class="headerlink" title="MinGW-w64 的 mingw64 文件夹"></a>MinGW-w64 的 mingw64 文件夹</h2><p><img src="https://img.50121.top/img/2020/02/200217_25.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>mingw64 中包含了一系列的文件夹，根据文件夹的名称，大概能猜到它们是做什么用的，但我们暂时不需要完全明白，只需要知道其中 bin 文件夹中，存放了那些编译工具即可。</p>
<p><strong>操作：</strong>双击红框中的「<strong>bin</strong>」文件夹，进入其中。</p>
<p>　</p>
<h2 id="MinGW-w64-的-bin-文件夹"><a href="#MinGW-w64-的-bin-文件夹" class="headerlink" title="MinGW-w64 的 bin 文件夹"></a>MinGW-w64 的 bin 文件夹</h2><p><img src="https://img.50121.top/img/2020/02/200217_26.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>bin 文件夹下包含了很多后缀名是 .exe 的可执行程序，这些就是开发时所需的工具，如：gcc.exe 是用来编译 C程序的，g++.exe 是用来编译 C++ 程序的，而 gdb.exe 则是用来调试程序的 debug 工具。</p>
<p><strong>操作：</strong>点击红框中的地址栏，并复制（点击右键并点选<strong>复制</strong>，或快捷键：<strong>Ctrl + c</strong>）那一串地址。</p>
<p>　</p>
<h2 id="此电脑"><a href="#此电脑" class="headerlink" title="此电脑"></a>此电脑</h2><p><img src="https://img.50121.top/img/2020/02/200217_27.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>我们已经复制了 MinGW-w64 的 bin 文件夹的地址，接下来只要将它添加到系统的环境变量中，就可以完成 MinGW-w64 的全部配置了。</p>
<p><strong>操作：</strong>右键点击桌面上的「<strong>此电脑</strong>」，在弹出的菜单中点击红框中的「<strong>属性</strong>」项。</p>
<p>　</p>
<h2 id="计算机系统窗口"><a href="#计算机系统窗口" class="headerlink" title="计算机系统窗口"></a>计算机系统窗口</h2><p><img src="https://img.50121.top/img/2020/02/200217_28.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>这个窗口也可以通过「控制面板」 -&gt; 「系统和安全」 -&gt; 「系统」来打开。（如果你不知道自己的系统是 32位 还是 64位，也可以在这里查看。）</p>
<p><strong>操作：</strong>点击红框中的「<strong>高级系统设置</strong>」链接，将打开「<strong>系统属性</strong>」窗口。</p>
<p>　</p>
<h2 id="系统属性窗口"><a href="#系统属性窗口" class="headerlink" title="系统属性窗口"></a>系统属性窗口</h2><p><img src="https://img.50121.top/img/2020/02/200217_29.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>所谓的「<strong>环境变量</strong>」其实就是各种程序的默认安装目录，在那里有可执行程序。</p>
<p><strong>操作：</strong>点击红框中的「<strong>环境变量</strong>」按钮，将打开「<strong>环境变量</strong>」窗口。</p>
<p>　</p>
<h2 id="系统环境变量窗口"><a href="#系统环境变量窗口" class="headerlink" title="系统环境变量窗口"></a>系统环境变量窗口</h2><p><img src="https://img.50121.top/img/2020/02/200217_30.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>在这个窗口中我们可以编辑系统的环境变量，很多软件在安装的时候，会自动编辑环境变量。MinGW-w64 的安装程序比较简陋，只能由我们手动编辑。</p>
<p><strong>操作：</strong>首先点击选中绿框中的「<strong>Path</strong>」项，然后再点击红框中的「<strong>编辑</strong>」按钮。</p>
<p>　</p>
<h2 id="编辑-Path-环境变量"><a href="#编辑-Path-环境变量" class="headerlink" title="编辑 Path 环境变量"></a>编辑 Path 环境变量</h2><p><img src="https://img.50121.top/img/2020/02/200217_31.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>这是 Windows 10 中的编辑界面，比之前的版本要清晰明了，操作简单了很多，也不容易出错了。</p>
<p><strong>操作：</strong>点击红框中的「<strong>新建</strong>」按钮，将创建一个新的空白变量位置。</p>
<p>　</p>
<h2 id="新建-MinGW-w64-的环境变量"><a href="#新建-MinGW-w64-的环境变量" class="headerlink" title="新建 MinGW-w64 的环境变量"></a>新建 MinGW-w64 的环境变量</h2><p><img src="https://img.50121.top/img/2020/02/200217_32.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>现在只需将之前复制的 MinGW-w64 的 bin 文件夹地址，复制到新增的空白变量位置里，即可完成 MinGW-w64 的配置工作。</p>
<p><strong>操作：</strong>将 bin 文件夹地址，粘贴（点击右键并点选<strong>粘贴</strong>，或快捷键：<strong>Ctrl + v</strong>）到红框中的输入框中。</p>
<p>　</p>
<h2 id="添加-MinGW-w64-环境变量已完成"><a href="#添加-MinGW-w64-环境变量已完成" class="headerlink" title="添加 MinGW-w64 环境变量已完成"></a>添加 MinGW-w64 环境变量已完成</h2><p><img src="https://img.50121.top/img/2020/02/200217_33.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>MinGW-w64 的环境变量已经添加完毕。</p>
<p><strong>操作：</strong>点击红框中的「<strong>确定</strong>」按钮，MinGW-w64 的配置就完成了。</p>
<p>　</p>
<h2 id="启动「命令提示符」"><a href="#启动「命令提示符」" class="headerlink" title="启动「命令提示符」"></a>启动「命令提示符」</h2><p><img src="https://img.50121.top/img/2020/02/200217_34.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>为了测试 MinGW-w64 是否配置成功，我们需要在「<strong>命令提示符</strong>」中执行一个命令。所以要先启动「<strong>命令提示符</strong>」，值得注意的是各个 Windows 版本的启动方式不同，但都可以通过打开「<strong>运行</strong>」窗口，输入「<strong>cmd</strong>」来打开它。<br><strong>操作：</strong>右键点击 <strong>开始</strong> 按钮，在弹出的菜单中点击红框中的「<strong>命令提示符</strong>」项。</p>
<p>　</p>
<h2 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h2><p><img src="https://img.50121.top/img/2020/02/200217_35.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>MinGW-w64 是命令行工具，如果不与其他软件配合，则只能通过「命令提示符」来调用。</p>
<p><strong>操作：</strong>输入「<strong>gcc -v</strong>」 并按回车键（<strong>Enter</strong>），将会显示 MinGW-w64 的组件列表。</p>
<p>　</p>
<h2 id="MinGW-w64-安装完成"><a href="#MinGW-w64-安装完成" class="headerlink" title="MinGW-w64 安装完成"></a>MinGW-w64 安装完成</h2><p><img src="https://img.50121.top/img/2020/02/200217_36.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>说明：</strong>如果你的「命令提示符」显示了一大串组件信息，那说明你的 MinGW-w64 已经安装完成了，恭喜！</p>
<p><strong>操作：</strong>从现在开始你就可以用 MinGW-w64 来编译 C程序 了。</p>
<p>　</p>
<p>　</p>
<h1 id="使用-MinGW-w64-编译源代码"><a href="#使用-MinGW-w64-编译源代码" class="headerlink" title="使用 MinGW-w64 编译源代码"></a>使用 MinGW-w64 编译源代码</h1><p>MinGW-w64 没有图形用户界面，它其实是一组命令行工具集，任何操作都只能通过在「命令提示符」中输入命令的形式来执行。对于编程来说，这种命令行工具尤其独特的优势，那就是不用双手离开键盘，即可完成所有操作。鼠标虽然使用简单方便，但效率仍然不及键盘。而且，给一个程序开发图形用户界面，是一件非常麻烦的事情，因为它是与平台紧密相关的，你要考虑各个平台的不同。</p>
<p>当然，世界上还是有很多拥有漂亮的图形用户界面的集成开发环境（IDE），其中的一些内置的编译器就是 MinGW-w64(GCC) ，例如：Code Lite、Code::Blocks 等。</p>
<p>　</p>
<h2 id="编译命令-gcc"><a href="#编译命令-gcc" class="headerlink" title="编译命令 gcc"></a>编译命令 gcc</h2><p><img src="https://img.50121.top/img/2020/02/200217_37.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>格式：</strong>gcc 源代码文件的完整名字</p>
<p><strong>示例：</strong>gcc hello.c</p>
<p><strong>说明：</strong>「gcc」是 MinGW-w64 内置的编译命令，「hello.c」则是我们要编译的源代码文件的名字。</p>
<p><strong>注意：</strong>首先，「gcc」命令与源代码的文件名之间有一个空格。其次，文件名必须完整正确，不能省略后缀名「.c」。</p>
<p>因为 MinGW-w64 本来就是将 GCC 移植到 Windows 上的产物，所以操作方式和 GCC 一样，只是在 Linux 下命令是被键入到「终端」中，而 Windows 下则是被键入到「命令提示符」里。</p>
<p>　</p>
<h2 id="创建-hello-c-源代码文件"><a href="#创建-hello-c-源代码文件" class="headerlink" title="创建 hello.c 源代码文件"></a>创建 hello.c 源代码文件</h2><p><img src="https://img.50121.top/img/2020/02/200217_38.png" srcset="/img/loading.gif" lazyload></p>
<p>在用「gcc」命令编译源代码之前，我们首先要有一个存储了C语言代码的文件。C语言的源代码文件其实就是普通的文本文件，唯一的区别就是后缀名不同，文本文件的后缀名是「.txt」，而C语言源代码文件的后缀名是「.c」。</p>
<p>所以我们新建一个文本文件，名字可以任意取，我这里就将其命名为「hello」，现在文件的完整名字就是「hello.txt」了。之后我们只需要把「hello.txt」的后缀名「.txt」更改为「.c」后缀名，这样就得到了 C语言 源代码文件「<strong>hello.c</strong>」了。</p>
<p>　</p>
<h2 id="编写-hello-world-源代码"><a href="#编写-hello-world-源代码" class="headerlink" title="编写 hello, world 源代码"></a>编写 hello, world 源代码</h2><p><img src="https://img.50121.top/img/2020/02/200217_39.png" srcset="/img/loading.gif" lazyload></p>
<p>这里用 Windows 自带的记事本或任意文本编辑器，将「hello.c」这个源代码文件打开，然后将上图所示的测试代码键入到文件中，最后保存文件即可。现在测试用的源代码文件已经准备完成，我们可以进行下一步的编译了。</p>
<p>这段代码是最基础的 hello, world 程序，会在屏幕上显示「hello, world」这段文字。相信这是学编程的大多数人，入门时的第一个程序，所以这里也就不再赘述了。</p>
<p>　</p>
<h2 id="编译-hello-c-源代码"><a href="#编译-hello-c-源代码" class="headerlink" title="编译 hello.c 源代码"></a>编译 hello.c 源代码</h2><p><img src="https://img.50121.top/img/2020/02/200217_40.png" srcset="/img/loading.gif" lazyload></p>
<p>之前说过 MinGW-w64 是命令行工具没有图形用户界面，所以编译操作需要在命令提示符中进行。</p>
<p>首先我们打开命令提示符，然后要将工作目录定位到源代码文件的存储位置，这一步非常重要，没有接触过命令行工具的人，往往会在这里出错。DOS 命令「cd」可以改变当前的工作目录，具体做法是「cd」命令后面加上目标工作目录，如上图第三行，就是重新定位到 E盘的 a 目录下。使用完「cd」命令后，还要再键入一次定位到的目录的地址，这样才会转移过去，但只需要键入盘符即可，并不需要键入完整地址，如上图第四行。工作目录重新定位后，如上图第五行所示，工作目录已经从 C:\Users\lenovo 更改为 E:\a 。</p>
<p>现在我们只需要执行「<strong>gcc hello.c</strong>」这行命令，就可以将源代码编译为可执行程序了。</p>
<p>　</p>
<h2 id="编译后生成-a-exe-可执行程序"><a href="#编译后生成-a-exe-可执行程序" class="headerlink" title="编译后生成 a.exe 可执行程序"></a>编译后生成 a.exe 可执行程序</h2><p><img src="https://img.50121.top/img/2020/02/200217_41.png" srcset="/img/loading.gif" lazyload></p>
<p>如上图所示，a.exe 就是编译后生成的可执行程序。因为我们编译时没有指定生成的程序名，所以 MinGW-w64 默认将程序命名为 a ，加上后缀名就是 a.exe 了。如果我们想在编译时就指定生成的程序名，就需要使用「gcc」命令的「-o」选项了。</p>
<p>　</p>
<h2 id="带-o-参数的-gcc-命令"><a href="#带-o-参数的-gcc-命令" class="headerlink" title="带 -o 参数的 gcc 命令"></a>带 -o 参数的 gcc 命令</h2><p><img src="https://img.50121.top/img/2020/02/200217_42.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>格式：</strong>gcc 源代码文件的名字 -o 编译后程序的名字</p>
<p><strong>示例：</strong>gcc hello.c -o hello.exe</p>
<p><strong>说明：</strong>「gcc」这个命令拥有很多内置选项，其中「-o」表示将它后面的单词设置编译后文件的名字。</p>
<p><strong>注意：</strong>选项「o」是英文的小写字母，并不是数字零，并且它的后面只能是想设置的文件名。</p>
<p>这种在编译时命名的方法好像很鸡肋，初看好像只是帮我们省了一些时间，毕竟我们也可以在编译后手动改名。这种想法是因为我们的程序还很简单，只有一个源代码文件，也只会编译出一个程序。当以后我们的程序变复杂了，可能会在一个工作目录下编译出复数个程序，这时就必须用 -o 选项了，否则编译出的程序都叫 a.exe ，会在生成时互相覆盖掉。</p>
<p>　</p>
<h2 id="编译-hello-c-成-hello-exe"><a href="#编译-hello-c-成-hello-exe" class="headerlink" title="编译 hello.c 成 hello.exe"></a>编译 hello.c 成 hello.exe</h2><p><img src="https://img.50121.top/img/2020/02/200217_43.png" srcset="/img/loading.gif" lazyload></p>
<p>同样要先定位到我们在用的工作目录下，然后执行「<strong>gcc hello.c -o hello.exe</strong>」这条命令，就会编译生成一个名叫 hello.exe 的可执行文件了。</p>
<p>　</p>
<h2 id="编译后生成-hello-exe-可执行程序"><a href="#编译后生成-hello-exe-可执行程序" class="headerlink" title="编译后生成 hello.exe 可执行程序"></a>编译后生成 hello.exe 可执行程序</h2><p><img src="https://img.50121.top/img/2020/02/200217_44.png" srcset="/img/loading.gif" lazyload></p>
<p>执行完「gcc hello.c -o hello.exe」编译命令后，会在工作目录中生成 hello.exe 可执行程序，这就是我们得到的最终成果。</p>
<p>　</p>
<h2 id="双击运行-hello-exe"><a href="#双击运行-hello-exe" class="headerlink" title="双击运行 hello.exe"></a>双击运行 hello.exe</h2><p><img src="https://img.50121.top/img/2020/02/200217_45.png" srcset="/img/loading.gif" lazyload></p>
<p>用鼠标双击运行编译后的 hello.exe 程序，会启动一个命令提示符窗口，并在里面显示「hello, world」这几个字符。这代表我们成功的完成了一次编译，将那段C语言代码编译成了计算机可以执行的程序。</p>
<p>　</p>
<h2 id="在命令提示符中运行-hello-exe"><a href="#在命令提示符中运行-hello-exe" class="headerlink" title="在命令提示符中运行 hello.exe"></a>在命令提示符中运行 hello.exe</h2><p><img src="https://img.50121.top/img/2020/02/200217_46.png" srcset="/img/loading.gif" lazyload></p>
<p>想要运行编译好的程序，并不是非要用鼠标双击程序启动，也可在命令提示符中直接输入编译后的程序名称，例如输入「<strong>hello.exe</strong>」，也可以直接运行程序。甚至可以省略程序的后缀名，只需输入「<strong>hello</strong>」即可，程序同样会正确的运行。</p>
<p>　</p>
<p>　</p>
<h1 id="一些额外的设置"><a href="#一些额外的设置" class="headerlink" title="一些额外的设置"></a>一些额外的设置</h1><p>这些额外的设置，可以使 MinGW-w64 使用起来更方便。因为「gcc」命令有些麻烦，每次编译都要输入类似「gcc hello.c -o hello.exe」这样的一串字符，所以我们为了简化这一步骤，转而使用「make」命令。只是「make」是 Linux 和 类Unix 下的工具，所以在 MinGW-w64 中需要一些额外的修改。</p>
<p>　</p>
<h2 id="创建-gcc-exe-的副本-cc-exe"><a href="#创建-gcc-exe-的副本-cc-exe" class="headerlink" title="创建 gcc.exe 的副本 cc.exe"></a>创建 gcc.exe 的副本 cc.exe</h2><p><img src="https://img.50121.top/img/2020/02/200217_47.png" srcset="/img/loading.gif" lazyload></p>
<p>首先复制一个「<strong>gcc.exe</strong>」的副本，然后将其更名为「<strong>cc.exe</strong>」即可。</p>
<p>　</p>
<h2 id="创建-mingw32-make-exe-的副本-make-exe"><a href="#创建-mingw32-make-exe-的副本-make-exe" class="headerlink" title="创建 mingw32-make.exe 的副本 make.exe"></a>创建 mingw32-make.exe 的副本 make.exe</h2><p><img src="https://img.50121.top/img/2020/02/200217_48.png" srcset="/img/loading.gif" lazyload></p>
<p>与对「gcc.exe」的操作相同，复制一个「<strong>mingw32-make.exe</strong>」的副本，然后更名为「<strong>make.exe</strong>」。</p>
<p>　</p>
<h2 id="使用-make-命令编译源代码"><a href="#使用-make-命令编译源代码" class="headerlink" title="使用 make 命令编译源代码"></a>使用 make 命令编译源代码</h2><p><img src="https://img.50121.top/img/2020/02/200217_49.png" srcset="/img/loading.gif" lazyload></p>
<p>现在我们就可以使用「make」命令来编译源代码，只需要输入「<strong>make hello</strong>」即可编译生成「hello.exe」了。</p>
<p>　</p>
<p>　</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>上述只是简单的编译源代码的方法，适用于单个或少量源代码文件，如果是复杂的大型程序，要用到 makefile 来组织源代码时，就需要 mingw32-make（修改后使用 make） 命令了。</p>
<p>如果程序编译或运行出错，需要调试源代码，则可以使用 gdb 命令，来帮助我们确定问题产生在哪里。</p>
<p>如果代码没有明显的编译错误，运行时也没有逻辑错误，则在最终编译为可发布版的程序时，我们还要考虑编译优化的问题，以便生成的程序文件拥有更小的体积，和更高的运行效率。gcc 命令有 -00 、 -01 、 -02 、 -03 这几个优化选项，其中 -00 是默认选项，意思是无优化，剩下的几个选项随数字的增大，优化程度也会逐渐增强。</p>
<p>　</p>
<p>　</p>
<h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><p>这里会列出一些可以预见的问题，并提供解决问题方法。</p>
<p>　</p>
<h2 id="如果「自动安装程序」无法下载组件"><a href="#如果「自动安装程序」无法下载组件" class="headerlink" title="如果「自动安装程序」无法下载组件"></a>如果「自动安装程序」无法下载组件</h2><p><img src="https://img.50121.top/img/2020/02/200217_50.png" srcset="/img/loading.gif" lazyload></p>
<p>说明：如果网络环境不太好，或因宽带提供商的限制，可能会导致程序下载组件非常的缓慢，甚至会失败。这种时候，我们可以不用安装程序，而是尝试直接手动下载 MinGW-w64 的压缩包。这种方法的好处是可以使用第三方下载软件，而这种下载软件大多提供加速下载，以及断点续传功能。基本能解决无法下载的问题。</p>
<p>操作：如上图所示。将第四章、第3节 SourceForge 中的 MinGW-w64 下载页面往下拉，就能看到这部分的页面。其中，红框内的链接，就是 MinGW-w64 的压缩包手动下载链接（6.3.0版），只需根据需要选择对应的链接下载即可。例如：x86_64-win32-seh ，x86_64 指 64位，win32 指可开发 Windows 程序，seh 指 异常处理模型。</p>
<p>将 MinGW-w64 压缩包下载到本地后，解压缩，然后就可以照常进行配置了。</p>
<p>　</p>
<p>　</p>

                
              </div>
            
            <hr/>
            <!-- 已修改-新增：打赏代码 开始 -->
            <div>
              <details style="text-align:center">
                <summary style="font-size:1.7em; color: #f2481b;">捐赠一元，支持一下！</summary>
                <img src="/thanks/r2net_alipay.jpg" srcset="/img/loading.gif" lazyload style="width:150px; height:150px;">　
                <img src="/thanks/r2net_wechatpay.jpg" srcset="/img/loading.gif" lazyload style="width:150px; height:150px;">
                <p>注：捐赠时如在留言中注明网名或昵称，即可被列入到感谢名单中。否则，会以佚名身份列入名单。</p>
              </details>
            </div>
            <hr/>
            <!-- 已修改-新增：打赏代码 结束 -->
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%99%E7%A8%8B/" class="category-chain-item">教程</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%95%99%E7%A8%8B/%E5%B7%A5%E5%85%B7/" class="category-chain-item">工具</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C%E8%AF%AD%E8%A8%80/" class="print-no-link">#C语言</a>
      
        <a href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" class="print-no-link">#编译器</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>简单易懂的MinGW-w64安装教程：著名C语言编译器GCC的Windows版本</div>
      <div>https://rsreland.net/blog/202002172024/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>百二一</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年2月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/202002181719/" title="《Dr.るっる(露露医生)》日文原版漫画，全3卷，已完结。">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《Dr.るっる(露露医生)》日文原版漫画，全3卷，已完结。</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/202002161456/" title="「野中柚希(のなか ゆき｜Nonaka Yuki)内衣」临摹线稿">
                        <span class="hidden-mobile">「野中柚希(のなか ゆき｜Nonaka Yuki)内衣」临摹线稿</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"EKdmASjIRBzDpmdhjJvD7sQ7-MdYXbMMI","appKey":"3xhpLOaU8oKm2IGn0JVL08dW","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":true,"serverURLs":"https://leancloud.rsreland.net","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

      <!-- 已修改-新增：相关文章 开始 -->
      <aside class="sidebar" style="padding-left: 0rem; margin-right: 1rem; position: sticky; top: 64px;">
        
            <section class="related-posts">
                <h5><b>= 相关文章 =</b></h5>
                <ul>
                
                        <li><a href="/blog/202002291151/">在Emacs中用ediff比较文件时出错的解决方法</a></li>
                        
                        <li><a href="/blog/202002291102/">简单易懂的GNU Emacs安装教程：世界著名的顶级全能文本编辑器</a></li>
                        
                        <li><a href="/blog/202510152329/">重置git仓库以精简Github和Vercel空间大小</a></li>
                        
                </ul>
            </section>
        
      </aside>
      <!-- 已修改-新增：相关文章 结束 -->
    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
